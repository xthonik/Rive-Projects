<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kolesa Spareparts Ads — Recs & Chart</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@rive-app/canvas@latest"></script>
    <style>
        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg: #1D2129;
            --surface: #2B313D;
            --surface-hover: #32394a;
            --border: #3d4659;
            --text: #e4e6ed;
            --text-muted: #8b8fa3;
            --accent: #1A7BEB;
            --accent-light: #6EB1FF;
            --success: #1A7BEB;
            --warning: #fdcb6e;
            --danger: #ff7675;
            --radius: 12px;
            --radius-sm: 8px;
        }

        html,
        body {
            height: 100%;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
        }

        body {
            display: flex;
            flex-direction: column;
        }

        /* ── Header ─────────────────────────────── */
        .header {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px 24px;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
        }

        .header h1 {
            font-size: 18px;
            font-weight: 700;
            color: var(--accent-light);
        }

        .header .badge {
            font-size: 11px;
            font-weight: 600;
            padding: 3px 10px;
            border-radius: 20px;
            background: rgba(26, 123, 235, .1);
            color: var(--accent-light);
            letter-spacing: .5px;
        }

        /* ── Main Layout ────────────────────────── */
        .main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* ── Canvas Panel ───────────────────────── */
        .canvas-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 24px;
            padding: 24px;
            position: relative;
            background: var(--bg);
            overflow-y: auto;
        }

        .artboard-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .artboard-label {
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            padding: 4px 12px;
            border-radius: 20px;
            background: rgba(26, 123, 235, .08);
        }

        .rive-canvas {
            width: 360px;
            height: 640px;
            border-radius: var(--radius);
            background: var(--surface);
            outline: 1px solid var(--border);
        }

        /* ── Canvas Size Sliders ────────────────── */
        .canvas-size-section {
            padding: 12px 0;
        }

        .canvas-size-section h4 {
            font-size: 12px;
            font-weight: 600;
            color: var(--accent-light);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: .5px;
        }

        .size-slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 0;
        }

        .size-slider-row label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-muted);
            min-width: 16px;
        }

        .size-slider-row input[type="range"] {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--border);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .size-slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            box-shadow: 0 1px 4px rgba(0, 0, 0, .3);
        }

        .size-slider-row .size-value {
            font-size: 11px;
            font-weight: 600;
            color: var(--text);
            min-width: 42px;
            text-align: right;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
        }

        .size-dimensions {
            text-align: center;
            font-size: 11px;
            color: var(--text-muted);
            padding: 4px 0 0;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
        }

        /* ── Sidebar Controls ──────────────────── */
        .sidebar {
            width: 400px;
            min-width: 400px;
            border-left: 1px solid var(--border);
            background: var(--surface);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }

        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        .sidebar-header {
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--surface);
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-header h2 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* ── Section ────────────────────────────── */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 20px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-muted);
            cursor: pointer;
            user-select: none;
            transition: background .15s;
        }

        .section-title:hover {
            background: var(--surface-hover);
        }

        .section-title .icon {
            font-size: 11px;
            transition: transform .2s;
        }

        .section.collapsed .section-title .icon {
            transform: rotate(-90deg);
        }

        .section.collapsed .section-body {
            display: none;
        }

        .section-body {
            padding: 4px 20px 16px;
        }

        /* ── Control Row ────────────────────────── */
        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, .03);
            gap: 12px;
        }

        .control-row:last-child {
            border-bottom: none;
        }

        .control-label {
            font-size: 13px;
            font-weight: 500;
            color: var(--text);
            flex-shrink: 0;
            max-width: 50%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .control-type {
            font-size: 10px;
            font-weight: 600;
            padding: 2px 7px;
            border-radius: 4px;
            letter-spacing: .4px;
            text-transform: uppercase;
            flex-shrink: 0;
        }

        .type-boolean {
            background: rgba(26, 123, 235, .12);
            color: var(--success);
        }

        .type-number {
            background: rgba(26, 123, 235, .1);
            color: var(--accent-light);
        }

        .type-trigger {
            background: rgba(253, 203, 110, .12);
            color: var(--warning);
        }

        .type-string {
            background: rgba(255, 118, 117, .12);
            color: var(--danger);
        }

        .type-enum {
            background: rgba(26, 123, 235, .1);
            color: var(--accent-light);
        }

        .type-color {
            background: rgba(26, 123, 235, .12);
            color: var(--success);
        }

        .type-list {
            background: rgba(253, 203, 110, .12);
            color: var(--warning);
        }

        .type-viewmodel {
            background: rgba(26, 123, 235, .1);
            color: var(--accent-light);
        }

        .control-widget {
            flex-shrink: 0;
        }

        .control-left {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            min-width: 0;
        }

        /* ── Artboard Indicator ───────────────────── */
        .artboard-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 8px 0 4px;
            font-size: 11px;
            font-weight: 600;
            color: var(--success);
            letter-spacing: .3px;
        }

        .artboard-indicator .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success);
        }

        /* ── Toggle Switch ──────────────────────── */
        .toggle {
            display: inline-block;
            position: relative;
            width: 44px;
            height: 24px;
            cursor: pointer;
        }

        .toggle input {
            display: none;
        }

        .toggle-track {
            position: absolute;
            inset: 0;
            border-radius: 12px;
            background: var(--border);
            transition: background .2s;
        }

        .toggle input:checked+.toggle-track {
            background: var(--accent);
        }

        .toggle-thumb {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            transition: transform .2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, .3);
        }

        .toggle input:checked~.toggle-thumb {
            transform: translateX(20px);
        }

        /* ── Inputs ─────────────────────────────── */
        .number-input,
        .text-input {
            padding: 6px 10px;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            background: var(--bg);
            color: var(--text);
            font-size: 13px;
            font-family: 'Inter', sans-serif;
            outline: none;
            transition: border-color .15s;
        }

        .number-input {
            width: 80px;
            text-align: center;
        }

        .text-input {
            width: 150px;
        }

        .number-input:focus,
        .text-input:focus {
            border-color: var(--accent);
        }

        /* ── Select ─────────────────────────────── */
        .select-input {
            padding: 6px 28px 6px 10px;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            background: var(--bg);
            color: var(--text);
            font-size: 13px;
            font-family: 'Inter', sans-serif;
            outline: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%238b8fa3'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            cursor: pointer;
            transition: border-color .15s;
        }

        .select-input:focus {
            border-color: var(--accent);
        }

        /* ── Trigger Button ─────────────────────── */
        .trigger-btn {
            padding: 6px 16px;
            border: 1px solid var(--warning);
            border-radius: var(--radius-sm);
            background: rgba(253, 203, 110, .08);
            color: var(--warning);
            font-size: 12px;
            font-weight: 600;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all .15s;
            text-transform: uppercase;
            letter-spacing: .5px;
        }

        .trigger-btn:hover {
            background: rgba(253, 203, 110, .18);
        }

        .trigger-btn:active {
            transform: scale(.95);
            background: rgba(253, 203, 110, .25);
        }

        /* ── Color Swatch ───────────────────────── */
        .color-input-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 2px solid var(--border);
            cursor: pointer;
            padding: 0;
            overflow: hidden;
        }

        .color-swatch::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-swatch::-webkit-color-swatch {
            border: none;
        }

        /* ── Info Row ────────────────────────────── */
        .info-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 13px;
        }

        .info-row .label {
            color: var(--text-muted);
        }

        .info-row .value {
            color: var(--text);
            font-weight: 500;
            background: var(--bg);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* ── Loading & Empty ────────────────────── */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            gap: 16px;
        }

        .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading p {
            font-size: 13px;
            color: var(--text-muted);
        }

        .empty-state {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-muted);
        }

        .empty-state .icon {
            font-size: 32px;
            margin-bottom: 12px;
        }

        .empty-state p {
            font-size: 13px;
        }

        /* ── Console ────────────────────────────── */
        .console-section {
            border-top: 1px solid var(--border);
        }

        .console-log {
            max-height: 200px;
            overflow-y: auto;
            padding: 10px 20px;
            background: rgba(0, 0, 0, .2);
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 11px;
            line-height: 1.6;
        }

        .console-log .log-entry {
            color: var(--text-muted);
        }

        .console-log .log-entry.info {
            color: var(--accent-light);
        }

        .console-log .log-entry.success {
            color: var(--success);
        }

        .console-log .log-entry.warn {
            color: var(--warning);
        }

        .console-log .log-entry.error {
            color: var(--danger);
        }

        /* ── Responsive ─────────────────────────── */
        @media (max-width: 1200px) {
            .canvas-panel {
                flex-direction: column;
                gap: 16px;
            }

            .rive-canvas {
                max-width: 300px;
                max-height: 40vh;
            }
        }

        @media (max-width: 860px) {
            .main {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                min-width: auto;
                border-left: none;
                border-top: 1px solid var(--border);
                max-height: 50vh;
            }

            .canvas-panel {
                padding: 16px;
                flex-direction: column;
                gap: 12px;
            }

            .rive-canvas {
                max-width: 100%;
                max-height: 35vh;
            }
        }
    </style>
</head>

<body>
    <!-- Header -->
    <div class="header">
        <h1>Kolesa Spareparts Ads</h1>
    </div>

    <!-- Main Layout -->
    <div class="main">
        <div class="canvas-panel">
            <div class="artboard-wrapper">
                <span class="artboard-label">Chart</span>
                <canvas id="rive-canvas-chart" class="rive-canvas" style="width:328px;height:200px"></canvas>
            </div>
            <div class="artboard-wrapper">
                <span class="artboard-label">Recs</span>
                <canvas id="rive-canvas-recs" class="rive-canvas" style="width:328px;height:440px"></canvas>
            </div>
        </div>

        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h2>Data-Bound Properties</h2>
            </div>
            <div id="controls-container">
                <div class="loading" id="loading-state">
                    <div class="spinner"></div>
                    <p>Loading Rive file…</p>
                </div>
            </div>
            <!-- Console -->
            <div class="console-section">
                <div class="section-title"
                    onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'">
                    <span>Console</span>
                    <span class="icon">▼</span>
                </div>
                <div class="console-log" id="console-log"></div>
            </div>
        </div>
    </div>

    <script>
        // ─── Logging ────────────────────────────────
        const logEl = document.getElementById('console-log');
        function log(msg, type = '') {
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
            console.log(msg);
        }

        // ─── Globals ────────────────────────────────
        const RIV_FILE = 'spareparts_ads_prod.riv';
        let riveRecs = null;
        let riveChart = null;
        let fileEnums = null;
        const controlsContainer = document.getElementById('controls-container');

        // ─── Helpers ────────────────────────────────
        function createSection(title, id, collapsed = false) {
            const s = document.createElement('div');
            s.className = 'section' + (collapsed ? ' collapsed' : '');
            s.id = id;
            s.innerHTML = `
        <div class="section-title" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>${title}</span>
          <span class="icon">▼</span>
        </div>
        <div class="section-body"></div>`;
            return s;
        }

        function createControlRow(label, typeLabel, typeClass, widget) {
            const row = document.createElement('div');
            row.className = 'control-row';
            const left = document.createElement('div');
            left.className = 'control-left';
            const nameSpan = document.createElement('span');
            nameSpan.className = 'control-label';
            nameSpan.textContent = label;
            nameSpan.title = label;
            const typeSpan = document.createElement('span');
            typeSpan.className = 'control-type ' + typeClass;
            typeSpan.textContent = typeLabel;
            left.appendChild(nameSpan);
            left.appendChild(typeSpan);
            row.appendChild(left);
            const w = document.createElement('div');
            w.className = 'control-widget';
            w.appendChild(widget);
            row.appendChild(w);
            return row;
        }

        function addArtboardIndicator(container, artboardName) {
            const ind = document.createElement('div');
            ind.className = 'artboard-indicator';
            ind.innerHTML = `<span class="dot"></span> Bound to: ${artboardName}`;
            container.appendChild(ind);
        }

        // ─── Widget Builders ────────────────────────
        function makeBooleanToggle(value, onChange) {
            const lbl = document.createElement('label');
            lbl.className = 'toggle';
            const inp = document.createElement('input');
            inp.type = 'checkbox';
            inp.checked = value;
            inp.addEventListener('change', () => onChange(inp.checked));
            const track = document.createElement('div');
            track.className = 'toggle-track';
            const thumb = document.createElement('div');
            thumb.className = 'toggle-thumb';
            lbl.append(inp, track, thumb);
            return lbl;
        }

        function makeNumberInput(value, onChange) {
            const inp = document.createElement('input');
            inp.type = 'number';
            inp.className = 'number-input';
            inp.value = value;
            inp.step = 'any';
            inp.addEventListener('input', () => onChange(parseFloat(inp.value) || 0));
            return inp;
        }

        function makeTextInput(value, onChange) {
            const inp = document.createElement('input');
            inp.type = 'text';
            inp.className = 'text-input';
            inp.value = value || '';
            inp.addEventListener('input', () => onChange(inp.value));
            return inp;
        }

        function makeTriggerButton(onFire) {
            const btn = document.createElement('button');
            btn.className = 'trigger-btn';
            btn.textContent = 'FIRE';
            btn.addEventListener('click', () => {
                onFire();
                btn.style.transform = 'scale(.92)';
                setTimeout(() => btn.style.transform = '', 150);
            });
            return btn;
        }

        function makeEnumSelect(currentValue, options, onChange) {
            const sel = document.createElement('select');
            sel.className = 'select-input';
            options.forEach(opt => {
                const o = document.createElement('option');
                o.value = opt;
                o.textContent = opt;
                if (opt === currentValue) o.selected = true;
                sel.appendChild(o);
            });
            sel.addEventListener('change', () => onChange(sel.value));
            return sel;
        }

        function makeColorInput(packedValue, onChange) {
            const r = ((packedValue >> 16) & 0xFF);
            const g = ((packedValue >> 8) & 0xFF);
            const b = (packedValue & 0xFF);
            const hex = '#' + [r, g, b].map(c => c.toString(16).padStart(2, '0')).join('');
            const wrapper = document.createElement('div');
            wrapper.className = 'color-input-wrapper';
            const inp = document.createElement('input');
            inp.type = 'color';
            inp.className = 'color-swatch';
            inp.value = hex;
            const hexLbl = document.createElement('span');
            hexLbl.style.cssText = 'font-size:12px;color:var(--text-muted)';
            hexLbl.textContent = hex;
            inp.addEventListener('input', () => {
                hexLbl.textContent = inp.value;
                const h = inp.value;
                const packed = (0xFF << 24)
                    | (parseInt(h.slice(1, 3), 16) << 16)
                    | (parseInt(h.slice(3, 5), 16) << 8)
                    | parseInt(h.slice(5, 7), 16);
                onChange(packed >>> 0);
            });
            wrapper.append(inp, hexLbl);
            return wrapper;
        }

        // ─── Get enum values from file-level enums ──
        function getEnumValuesFromFile(propertyName, enumProp) {
            if (!fileEnums || !Array.isArray(fileEnums)) return [];
            for (const e of fileEnums) {
                // Match by property name first
                if (e.name && e.name.toLowerCase() === propertyName.toLowerCase() && e.values) {
                    return e.values;
                }
                // Fallback: match by current value
                if (e.values && e.values.includes(enumProp?.value)) {
                    return e.values;
                }
            }
            return [];
        }

        // ─── Discover VM properties (flat, no nesting) ─────
        // allVMIs is an array of all view model instances to sync changes across
        function discoverVMProperties(vmi, container, allVMIs = [], pathPrefix = '') {
            let count = 0;

            let propList = null;
            try {
                propList = vmi.properties;
                if (propList && propList.length > 0) {
                    log(`  Found ${propList.length} properties in ControlsVM`, 'success');
                }
            } catch (e) {
                log(`  .properties not available: ${e.message}`, 'warn');
            }

            if (propList && propList.length > 0) {
                propList.forEach(prop => {
                    const name = prop.name || prop;
                    const type = (prop.type || '').toString().toLowerCase();
                    const fullPath = pathPrefix ? `${pathPrefix}/${name}` : name;

                    log(`  Property: "${name}" type="${type}"`, 'info');

                    let widget = null;
                    let typeLabel = type;
                    let typeClass = 'type-string';

                    try {
                        switch (type) {
                            case 'boolean': {
                                const p = vmi.boolean(name);
                                if (p) {
                                    typeClass = 'type-boolean';
                                    widget = makeBooleanToggle(p.value, val => {
                                        syncBooleanToAll(allVMIs, name, val);
                                        log(`${fullPath} = ${val}`, 'info');
                                    });
                                }
                                break;
                            }
                            case 'number': {
                                const p = vmi.number(name);
                                if (p) {
                                    typeClass = 'type-number';
                                    widget = makeNumberInput(p.value, val => {
                                        p.value = val;
                                        log(`${fullPath} = ${val}`, 'info');
                                    });
                                }
                                break;
                            }
                            case 'string': {
                                const p = vmi.string(name);
                                if (p) {
                                    typeClass = 'type-string';
                                    widget = makeTextInput(p.value, val => {
                                        p.value = val;
                                        log(`${fullPath} = "${val}"`, 'info');
                                    });
                                }
                                break;
                            }
                            case 'enum': {
                                const p = vmi.enum(name);
                                if (p) {
                                    typeClass = 'type-enum';
                                    let opts = [];
                                    try {
                                        if (typeof p.options === 'function') opts = p.options();
                                        else if (Array.isArray(p.options)) opts = p.options;
                                    } catch (e) { }
                                    if (opts.length === 0) {
                                        opts = getEnumValuesFromFile(name, p);
                                    }
                                    if (opts.length > 0) {
                                        widget = makeEnumSelect(p.value, opts, val => {
                                            syncEnumToAll(allVMIs, name, val);
                                            log(`${fullPath} = "${val}" (synced to all artboards)`, 'info');
                                        });
                                    } else {
                                        widget = makeTextInput(p.value, val => {
                                            syncEnumToAll(allVMIs, name, val);
                                            log(`${fullPath} = "${val}" (synced to all artboards)`, 'info');
                                        });
                                    }
                                }
                                break;
                            }
                            case 'color': {
                                const p = vmi.color(name);
                                if (p) {
                                    typeClass = 'type-color';
                                    widget = makeColorInput(p.value, val => {
                                        p.value = val;
                                        log(`${fullPath} color updated`, 'info');
                                    });
                                }
                                break;
                            }
                            case 'trigger': {
                                const p = vmi.trigger(name);
                                if (p) {
                                    typeClass = 'type-trigger';
                                    widget = makeTriggerButton(() => {
                                        if (typeof p.trigger === 'function') p.trigger();
                                        else if (typeof p.fire === 'function') p.fire();
                                        log(`${fullPath} fired!`, 'warn');
                                    });
                                }
                                break;
                            }
                            default: {
                                const tried = tryAllAccessors(vmi, name, fullPath);
                                if (tried) {
                                    widget = tried.widget;
                                    typeLabel = tried.typeLabel;
                                    typeClass = tried.typeClass;
                                }
                            }
                        }
                    } catch (e) {
                        log(`  Error accessing "${name}": ${e.message}`, 'error');
                    }

                    if (widget) {
                        container.appendChild(createControlRow(name, typeLabel, typeClass, widget));
                        count++;
                    }
                });
            } else {
                // No .properties — try known property names
                log(`  No .properties available, trying known property names…`, 'warn');
                count += probeKnownProperties(vmi, container, allVMIs, pathPrefix);
            }

            return count;
        }

        // ─── Sync helpers: update property on ALL VMIs ──
        function syncEnumToAll(allVMIs, name, val) {
            allVMIs.forEach(v => {
                try {
                    const p = v.enum(name);
                    if (p) p.value = val;
                } catch (e) { /* this VMI may not have this enum */ }
            });
        }

        function syncBooleanToAll(allVMIs, name, val) {
            allVMIs.forEach(v => {
                try {
                    const p = v.boolean(name);
                    if (p) p.value = val;
                } catch (e) { /* this VMI may not have this boolean */ }
            });
        }

        // ─── Try all accessor methods for a property ──
        function tryAllAccessors(vmi, name, fullPath) {
            const accessors = [
                { method: 'boolean', typeLabel: 'boolean', typeClass: 'type-boolean', makeWidget: (p) => makeBooleanToggle(p.value, v => { p.value = v; log(`${fullPath} = ${v}`, 'info'); }) },
                { method: 'number', typeLabel: 'number', typeClass: 'type-number', makeWidget: (p) => makeNumberInput(p.value, v => { p.value = v; log(`${fullPath} = ${v}`, 'info'); }) },
                { method: 'string', typeLabel: 'string', typeClass: 'type-string', makeWidget: (p) => makeTextInput(p.value, v => { p.value = v; log(`${fullPath} = "${v}"`, 'info'); }) },
                {
                    method: 'enum', typeLabel: 'enum', typeClass: 'type-enum', makeWidget: (p) => {
                        let opts = [];
                        try { opts = typeof p.options === 'function' ? p.options() : (Array.isArray(p.options) ? p.options : []); } catch (e) { }
                        if (opts.length === 0) opts = getEnumValuesFromFile(name, p);
                        return opts.length > 0
                            ? makeEnumSelect(p.value, opts, v => { p.value = v; log(`${fullPath} = "${v}"`, 'info'); })
                            : makeTextInput(p.value, v => { p.value = v; log(`${fullPath} = "${v}"`, 'info'); });
                    }
                },
                { method: 'color', typeLabel: 'color', typeClass: 'type-color', makeWidget: (p) => makeColorInput(p.value, v => { p.value = v; log(`${fullPath} color updated`, 'info'); }) },
                { method: 'trigger', typeLabel: 'trigger', typeClass: 'type-trigger', makeWidget: (p) => makeTriggerButton(() => { (p.trigger || p.fire).call(p); log(`${fullPath} fired!`, 'warn'); }) },
            ];

            for (const a of accessors) {
                if (typeof vmi[a.method] !== 'function') continue;
                try {
                    const p = vmi[a.method](name);
                    if (p != null) {
                        return { widget: a.makeWidget(p), typeLabel: a.typeLabel, typeClass: a.typeClass };
                    }
                } catch (e) { /* skip */ }
            }

            return null;
        }

        // ─── Fallback: probe known property names ───
        function probeKnownProperties(vmi, container, allVMIs, pathPrefix) {
            const knownNames = [
                'language', 'playChartAnimation',
                // General common names
                'lang', 'locale', 'title', 'subtitle', 'text', 'label', 'description', 'name',
                'price', 'old_price', 'new_price', 'discount', 'count', 'rating',
                'is_active', 'is_visible', 'liked', 'active', 'visible', 'enabled', 'selected',
                'color', 'bg_color', 'theme', 'state', 'status', 'type', 'category',
                'plus', 'premium', 'pro', 'vip',
                'fire', 'fire_animation', 'trigger', 'tap',
                'page', 'recs', 'progress', 'value',
                'part_name', 'store_name', 'part_price', 'ad_title', 'ad_text', 'ad_price',
                'phone', 'seller', 'in_stock', 'available', 'quantity',
                'delivery', 'warranty', 'condition', 'currency', 'badge',
                'button_text', 'cta', 'header', 'body', 'image', 'icon', 'photo',
            ];

            let count = 0;

            // Try language enum explicitly first — syncs to ALL artboards (Recs + Chart)
            try {
                const langEnum = vmi.enum('language');
                if (langEnum) {
                    log(`  ✓ Found enum: "language" = "${langEnum.value}"`, 'success');
                    let opts = ['ru', 'en', 'kk']; // Known values
                    try {
                        const runtimeOpts = typeof langEnum.options === 'function' ? langEnum.options() : langEnum.options;
                        if (runtimeOpts && runtimeOpts.length > 0) opts = runtimeOpts;
                    } catch (e) { }
                    const sel = makeEnumSelect(langEnum.value, opts, val => {
                        syncEnumToAll(allVMIs, 'language', val);
                        log(`language = "${val}" (synced to all artboards)`, 'info');
                    });
                    container.appendChild(createControlRow('language', 'enum', 'type-enum', sel));
                    count++;
                }
            } catch (e) {
                log(`  Error accessing language: ${e.message}`, 'error');
            }

            // Try playChartAnimation boolean explicitly — syncs to ALL artboards
            try {
                const chartBool = vmi.boolean('playChartAnimation');
                if (chartBool) {
                    log(`  ✓ Found boolean: "playChartAnimation" = ${chartBool.value}`, 'success');
                    const toggle = makeBooleanToggle(chartBool.value, val => {
                        syncBooleanToAll(allVMIs, 'playChartAnimation', val);
                        log(`playChartAnimation = ${val} (synced to all artboards)`, 'info');
                    });
                    container.appendChild(createControlRow('playChartAnimation', 'boolean', 'type-boolean', toggle));
                    count++;
                }
            } catch (e) {
                log(`  Error accessing playChartAnimation: ${e.message}`, 'error');
            }

            // Brute force remaining names
            knownNames.forEach(name => {
                if (name === 'language' || name === 'playChartAnimation') return; // already handled

                const fullPath = pathPrefix ? `${pathPrefix}/${name}` : name;
                const tried = tryAllAccessors(vmi, name, fullPath);
                if (tried) {
                    log(`  ✓ Found: "${name}" (${tried.typeLabel})`, 'success');
                    container.appendChild(createControlRow(name, tried.typeLabel, tried.typeClass, tried.widget));
                    count++;
                }
            });

            return count;
        }

        // ─── Build State Machine Inputs UI ──────────
        function buildSMInputsUI(riveInst, smName, artboardLabel) {
            const inputs = riveInst.stateMachineInputs(smName);
            if (!inputs || inputs.length === 0) {
                log(`  No inputs for SM "${smName}" (${artboardLabel})`, 'warn');
                return null;
            }
            const section = createSection(`⚙ SM: ${smName} (${artboardLabel})`, `sm-${artboardLabel}-${smName}`);
            const body = section.querySelector('.section-body');

            inputs.forEach(input => {
                let widget, typeLabel, typeClass;
                if (input.type === rive.StateMachineInputType.Boolean || input.type === 56) {
                    typeLabel = 'bool'; typeClass = 'type-boolean';
                    widget = makeBooleanToggle(input.value, v => { input.value = v; log(`SM.${input.name} = ${v}`, 'info'); });
                } else if (input.type === rive.StateMachineInputType.Number || input.type === 68) {
                    typeLabel = 'number'; typeClass = 'type-number';
                    widget = makeNumberInput(input.value, v => { input.value = v; log(`SM.${input.name} = ${v}`, 'info'); });
                } else if (input.type === rive.StateMachineInputType.Trigger || input.type === 58) {
                    typeLabel = 'trigger'; typeClass = 'type-trigger';
                    widget = makeTriggerButton(() => { input.fire(); log(`SM.${input.name} fired!`, 'warn'); });
                } else {
                    typeLabel = `t:${input.type}`; typeClass = 'type-string';
                    widget = makeTextInput(String(input.value ?? ''), v => { input.value = v; log(`SM.${input.name} = "${v}"`, 'info'); });
                }
                body.appendChild(createControlRow(input.name, typeLabel, typeClass, widget));
                log(`  SM Input: "${input.name}" (${typeLabel}) = ${input.value ?? '—'}`, 'info');
            });

            return section;
        }

        // ─── Build File Info UI ─────────────────────
        function buildFileInfoUI(riveInst) {
            const section = createSection('📄 File Info', 'file-info', true);
            const body = section.querySelector('.section-body');
            const contents = riveInst.contents;
            if (contents?.artboards) {
                contents.artboards.forEach(ab => {
                    const row = document.createElement('div');
                    row.className = 'info-row';
                    row.innerHTML = `<span class="label">Artboard</span><span class="value">${ab.name || 'unnamed'}</span>`;
                    body.appendChild(row);
                    (ab.stateMachines || []).forEach(sm => {
                        const r = document.createElement('div');
                        r.className = 'info-row';
                        r.style.paddingLeft = '16px';
                        r.innerHTML = `<span class="label">└ SM</span><span class="value">${sm.name || sm}</span>`;
                        body.appendChild(r);
                    });
                    (ab.animations || []).forEach(a => {
                        const r = document.createElement('div');
                        r.className = 'info-row';
                        r.style.paddingLeft = '16px';
                        r.innerHTML = `<span class="label">└ Anim</span><span class="value">${a.name || a}</span>`;
                        body.appendChild(r);
                    });
                });
            }

            // Show file-level enums
            if (fileEnums && fileEnums.length > 0) {
                fileEnums.forEach(e => {
                    const r = document.createElement('div');
                    r.className = 'info-row';
                    r.innerHTML = `<span class="label">Enum: ${e.name}</span><span class="value">${(e.values || []).join(', ')}</span>`;
                    body.appendChild(r);
                });
            }
            return section;
        }

        // ─── Rive Events ────────────────────────────
        function setupRiveEvents(riveInst, label) {
            try {
                if (rive?.EventType?.RiveEvent) {
                    riveInst.on(rive.EventType.RiveEvent, ev => {
                        log(`🎯 RiveEvent (${label}): "${ev?.data?.name || 'unknown'}"`, 'success');
                    });
                }
            } catch (e) { }
        }

        // ─── Initialize ─────────────────────────────
        function initRive() {
            log('Initializing Rive — loading both Recs & Chart artboards…');

            // Diagnostic load to discover artboards & state machines
            const diagCanvas = document.createElement('canvas');
            diagCanvas.width = 1;
            diagCanvas.height = 1;

            const diagRive = new rive.Rive({
                src: RIV_FILE,
                canvas: diagCanvas,
                onLoad: () => {
                    log('Diagnostic load complete', 'success');

                    const contents = diagRive.contents;
                    const artboards = contents?.artboards || [];

                    log(`Found ${artboards.length} artboard(s)`, 'info');
                    artboards.forEach(ab => log(`  • "${ab.name}"`, 'info'));

                    // Get file-level enums
                    try {
                        fileEnums = diagRive.enums();
                        if (fileEnums && fileEnums.length > 0) {
                            log(`Found ${fileEnums.length} file-level enum(s):`, 'info');
                            fileEnums.forEach(e => log(`  • ${e.name}: [${(e.values || []).join(', ')}]`, 'info'));
                        }
                    } catch (e) {
                        log(`Could not get file-level enums: ${e.message}`, 'warn');
                    }

                    // Find artboards
                    const recsAB = artboards.find(ab => ab.name === 'Recs' || ab.name.toLowerCase().includes('recs'));
                    const chartAB = artboards.find(ab => ab.name === 'Chart' || ab.name.toLowerCase().includes('chart'));

                    if (!recsAB) {
                        log('⚠ "Recs" artboard not found! Available artboards listed above.', 'error');
                    } else {
                        log(`✓ Found Recs artboard: "${recsAB.name}"`, 'success');
                    }
                    if (!chartAB) {
                        log('⚠ "Chart" artboard not found! Available artboards listed above.', 'error');
                    } else {
                        log(`✓ Found Chart artboard: "${chartAB.name}"`, 'success');
                    }

                    // Cleanup diagnostic instance
                    diagRive.cleanup();

                    let loadedCount = 0;
                    const totalToLoad = (recsAB ? 1 : 0) + (chartAB ? 1 : 0);

                    function onArtboardReady() {
                        loadedCount++;
                        if (loadedCount >= totalToLoad) {
                            // Remove loading spinner
                            const loadingEl = document.getElementById('loading-state');
                            if (loadingEl) loadingEl.remove();

                            // Build shared controls from ControlsVM
                            buildControlsVM();
                        }
                    }

                    // Load Recs artboard
                    if (recsAB) {
                        loadArtboard(recsAB, document.getElementById('rive-canvas-recs'), 'Recs', (inst) => {
                            riveRecs = inst;
                            onArtboardReady();
                        });
                    }

                    // Load Chart artboard
                    if (chartAB) {
                        loadArtboard(chartAB, document.getElementById('rive-canvas-chart'), 'Chart', (inst) => {
                            riveChart = inst;
                            onArtboardReady();
                        });
                    }

                    if (totalToLoad === 0) {
                        log('❌ Neither Recs nor Chart artboard found!', 'error');
                        const loadingEl = document.getElementById('loading-state');
                        if (loadingEl) {
                            loadingEl.innerHTML = '<div class="empty-state"><div class="icon">❌</div><p>No matching artboards found in the .riv file</p></div>';
                        }
                    }
                },
                onLoadError: err => {
                    log('❌ Diagnostic load failed: ' + err, 'error');
                }
            });
        }

        function loadArtboard(artboardDef, canvas, label, onDone) {
            const artboardName = artboardDef.name;
            const smNames = (artboardDef.stateMachines || []).map(sm => sm.name || sm);
            const firstSM = smNames[0];

            log(`Loading ${label} artboard: "${artboardName}", SM: "${firstSM || 'none'}"`, 'info');

            const riveInst = new rive.Rive({
                src: RIV_FILE,
                canvas: canvas,
                autoplay: true,
                autoBind: true,
                artboard: artboardName,
                stateMachines: firstSM || undefined,
                layout: new rive.Layout({
                    fit: rive.Fit.Layout,
                    alignment: rive.Alignment.Center,
                    layoutScaleFactor: 1
                }),
                onLoad: () => {
                    log(`✅ ${label} artboard "${artboardName}" loaded!`, 'success');
                    riveInst.resizeDrawingSurfaceToCanvas();

                    // Build SM inputs for this artboard
                    const allSMNames = riveInst.stateMachineNames || smNames;
                    allSMNames.forEach(smn => {
                        const smSection = buildSMInputsUI(riveInst, smn, label);
                        if (smSection) controlsContainer.appendChild(smSection);
                    });

                    // Events
                    setupRiveEvents(riveInst, label);

                    onDone(riveInst);
                },
                onLoadError: err => {
                    log(`❌ Failed to load ${label}: ${err}`, 'error');
                    onDone(null);
                }
            });
        }

        // ─── Build shared ControlsVM UI ──────────────
        function buildControlsVM() {
            log('Building ControlsVM controls…', 'info');

            // File Info (use whichever instance is available)
            const anyInst = riveRecs || riveChart;
            if (anyInst) {
                const fileInfo = buildFileInfoUI(anyInst);
                if (fileInfo) controlsContainer.appendChild(fileInfo);
            }

            // ── Canvas Size Sliders (Responsive Layout) ──
            function buildCanvasSizeSliders(label, canvasId, riveInst) {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return null;

                const section = createSection(`📐 ${label} — Canvas Size`, `size-${label.toLowerCase()}`);
                const body = section.querySelector('.section-body');

                const wrapper = document.createElement('div');
                wrapper.className = 'canvas-size-section';

                const currentW = canvas.clientWidth || 360;
                const currentH = canvas.clientHeight || 640;

                // Dimensions readout
                const dims = document.createElement('div');
                dims.className = 'size-dimensions';
                dims.textContent = `${currentW} × ${currentH}`;

                function resizeCanvas(w, h) {
                    canvas.style.width = w + 'px';
                    canvas.style.height = h + 'px';
                    dims.textContent = `${w} × ${h}`;
                    if (riveInst) {
                        riveInst.resizeDrawingSurfaceToCanvas();
                    }
                }

                // Width slider
                const wRow = document.createElement('div');
                wRow.className = 'size-slider-row';
                const wLabel = document.createElement('label');
                wLabel.textContent = 'W';
                const wSlider = document.createElement('input');
                wSlider.type = 'range';
                wSlider.min = '100';
                wSlider.max = '800';
                wSlider.value = currentW;
                const wVal = document.createElement('span');
                wVal.className = 'size-value';
                wVal.textContent = currentW + 'px';
                wSlider.addEventListener('input', () => {
                    const w = parseInt(wSlider.value);
                    wVal.textContent = w + 'px';
                    resizeCanvas(w, parseInt(hSlider.value));
                });
                wRow.append(wLabel, wSlider, wVal);

                // Height slider
                const hRow = document.createElement('div');
                hRow.className = 'size-slider-row';
                const hLabel = document.createElement('label');
                hLabel.textContent = 'H';
                const hSlider = document.createElement('input');
                hSlider.type = 'range';
                hSlider.min = '100';
                hSlider.max = '1200';
                hSlider.value = currentH;
                const hVal = document.createElement('span');
                hVal.className = 'size-value';
                hVal.textContent = currentH + 'px';
                hSlider.addEventListener('input', () => {
                    const h = parseInt(hSlider.value);
                    hVal.textContent = h + 'px';
                    resizeCanvas(parseInt(wSlider.value), h);
                });
                hRow.append(hLabel, hSlider, hVal);

                wrapper.append(wRow, hRow, dims);
                body.appendChild(wrapper);
                return section;
            }

            const chartSliders = buildCanvasSizeSliders('Chart', 'rive-canvas-chart', riveChart);
            if (chartSliders) controlsContainer.appendChild(chartSliders);

            const recsSliders = buildCanvasSizeSliders('Recs', 'rive-canvas-recs', riveRecs);
            if (recsSliders) controlsContainer.appendChild(recsSliders);

            // Get the viewModelInstance from each artboard — they share ControlsVM
            const vmiRecs = riveRecs?.viewModelInstance;
            const vmiChart = riveChart?.viewModelInstance;

            log(`Recs VMI: ${vmiRecs ? 'FOUND' : 'NOT FOUND'}`, vmiRecs ? 'success' : 'warn');
            log(`Chart VMI: ${vmiChart ? 'FOUND' : 'NOT FOUND'}`, vmiChart ? 'success' : 'warn');

            // Log prototype methods for diagnostics
            [['Recs', vmiRecs], ['Chart', vmiChart]].forEach(([label, vmi]) => {
                if (!vmi) return;
                try {
                    const proto = Object.getPrototypeOf(vmi);
                    const methods = Object.getOwnPropertyNames(proto).filter(m => m !== 'constructor');
                    log(`${label} VMI methods: ${methods.join(', ')}`, 'info');
                } catch (e) { }
                try {
                    const props = vmi.properties;
                    if (props) {
                        log(`${label} VMI properties: ${JSON.stringify(props.map(p => ({
                            name: p.name || p,
                            type: p.type || 'unknown'
                        })))}`, 'info');
                    }
                } catch (e) {
                    log(`${label} VMI .properties error: ${e.message}`, 'warn');
                }
            });

            const vmSection = createSection('🔗 ControlsVM — Data-Bound Properties', 'vm-section');
            const vmBody = vmSection.querySelector('.section-body');
            let propCount = 0;

            // ── Explicitly build "language" enum control ──
            // Grab the language enum handle from EVERY VMI that has it
            const langHandles = [];
            [['Recs', vmiRecs], ['Chart', vmiChart]].forEach(([label, vmi]) => {
                if (!vmi) return;
                try {
                    const h = vmi.enum('language');
                    if (h) {
                        langHandles.push({ label, handle: h });
                        log(`  ✓ language enum found on ${label} VMI, value="${h.value}"`, 'success');
                    }
                } catch (e) {
                    log(`  language enum not found on ${label}: ${e.message}`, 'warn');
                }
            });

            if (langHandles.length > 0) {
                let opts = ['ru', 'en', 'kk'];
                try {
                    const h0 = langHandles[0].handle;
                    const runtimeOpts = typeof h0.options === 'function' ? h0.options() : h0.options;
                    if (runtimeOpts && runtimeOpts.length > 0) opts = runtimeOpts;
                } catch (e) { }
                if (opts.length === 0 && fileEnums) {
                    opts = getEnumValuesFromFile('language', langHandles[0].handle);
                }

                const sel = makeEnumSelect(langHandles[0].handle.value, opts, val => {
                    langHandles.forEach(({ label, handle }) => {
                        try {
                            handle.value = val;
                            log(`  language = "${val}" on ${label}`, 'info');
                        } catch (e) {
                            log(`  Failed to set language on ${label}: ${e.message}`, 'error');
                        }
                    });
                });
                vmBody.appendChild(createControlRow('language', 'enum', 'type-enum', sel));
                propCount++;
                log(`  language enum control created (bound to ${langHandles.map(h => h.label).join(' + ')})`, 'success');
            } else {
                log('  ⚠ language enum not found on any VMI', 'warn');
            }

            // ── Explicitly build "playChartAnimation" boolean control ──
            // Grab the boolean handle from EVERY VMI that has it
            const playHandles = [];
            [['Recs', vmiRecs], ['Chart', vmiChart]].forEach(([label, vmi]) => {
                if (!vmi) return;
                try {
                    const h = vmi.boolean('playChartAnimation');
                    if (h) {
                        playHandles.push({ label, handle: h });
                        log(`  ✓ playChartAnimation boolean found on ${label} VMI, value=${h.value}`, 'success');
                    }
                } catch (e) {
                    log(`  playChartAnimation not found on ${label}: ${e.message}`, 'warn');
                }
            });

            // Force create toggle for playChartAnimation (Chart only)
            let chartVal = true;
            try {
                if (vmiChart) {
                    const h = vmiChart.boolean('playChartAnimation');
                    if (h) chartVal = h.value;
                }
            } catch (e) { }

            const toggle = makeBooleanToggle(chartVal, val => {
                if (vmiChart) {
                    try {
                        const h = vmiChart.boolean('playChartAnimation');
                        if (h) {
                            h.value = val;
                            log(`playChartAnimation = ${val} (Chart)`, 'info');
                        } else {
                            log('playChartAnimation property not found on Chart', 'warn');
                        }
                    } catch (e) { log(e.message, 'error'); }
                } else {
                    log('Chart VMI missing', 'warn');
                }
            });

            vmBody.appendChild(createControlRow('playChartAnimation', 'boolean', 'type-boolean', toggle));
            propCount++;


            // ── Discover any OTHER properties from both VMIs ──
            const allVMIs = [vmiRecs, vmiChart].filter(Boolean);
            const discoveredNames = new Set(['language', 'playChartAnimation']); // already handled

            allVMIs.forEach((vmi, idx) => {
                const label = idx === 0 ? 'Recs' : 'Chart';
                try {
                    const propList = vmi.properties;
                    if (propList && propList.length > 0) {
                        propList.forEach(prop => {
                            const name = prop.name || prop;
                            if (discoveredNames.has(name)) return; // skip already-handled
                            discoveredNames.add(name);

                            const type = (prop.type || '').toString().toLowerCase();
                            log(`  Extra property: "${name}" type="${type}" (from ${label})`, 'info');

                            let widget = null;
                            let typeLabel = type;
                            let typeClass = 'type-string';

                            try {
                                switch (type) {
                                    case 'boolean': {
                                        const p = vmi.boolean(name);
                                        if (p) {
                                            typeClass = 'type-boolean';
                                            widget = makeBooleanToggle(p.value, val => {
                                                // Sync to all VMIs
                                                allVMIs.forEach(v => { try { const h = v.boolean(name); if (h) h.value = val; } catch (e) { } });
                                                log(`${name} = ${val}`, 'info');
                                            });
                                        }
                                        break;
                                    }
                                    case 'number': {
                                        const p = vmi.number(name);
                                        if (p) {
                                            typeClass = 'type-number';
                                            widget = makeNumberInput(p.value, val => { p.value = val; log(`${name} = ${val}`, 'info'); });
                                        }
                                        break;
                                    }
                                    case 'string': {
                                        const p = vmi.string(name);
                                        if (p) {
                                            typeClass = 'type-string';
                                            widget = makeTextInput(p.value, val => { p.value = val; log(`${name} = "${val}"`, 'info'); });
                                        }
                                        break;
                                    }
                                    case 'enum': {
                                        const p = vmi.enum(name);
                                        if (p) {
                                            typeClass = 'type-enum';
                                            let opts = [];
                                            try {
                                                if (typeof p.options === 'function') opts = p.options();
                                                else if (Array.isArray(p.options)) opts = p.options;
                                            } catch (e) { }
                                            if (opts.length === 0) opts = getEnumValuesFromFile(name, p);
                                            widget = opts.length > 0
                                                ? makeEnumSelect(p.value, opts, val => {
                                                    allVMIs.forEach(v => { try { const h = v.enum(name); if (h) h.value = val; } catch (e) { } });
                                                    log(`${name} = "${val}"`, 'info');
                                                })
                                                : makeTextInput(p.value, val => { p.value = val; log(`${name} = "${val}"`, 'info'); });
                                        }
                                        break;
                                    }
                                    case 'color': {
                                        const p = vmi.color(name);
                                        if (p) {
                                            typeClass = 'type-color';
                                            widget = makeColorInput(p.value, val => { p.value = val; log(`${name} color updated`, 'info'); });
                                        }
                                        break;
                                    }
                                    case 'trigger': {
                                        const p = vmi.trigger(name);
                                        if (p) {
                                            typeClass = 'type-trigger';
                                            widget = makeTriggerButton(() => {
                                                if (typeof p.trigger === 'function') p.trigger();
                                                else if (typeof p.fire === 'function') p.fire();
                                                log(`${name} fired!`, 'warn');
                                            });
                                        }
                                        break;
                                    }
                                    default: {
                                        const tried = tryAllAccessors(vmi, name, name);
                                        if (tried) { widget = tried.widget; typeLabel = tried.typeLabel; typeClass = tried.typeClass; }
                                    }
                                }
                            } catch (e) {
                                log(`  Error accessing "${name}": ${e.message}`, 'error');
                            }

                            if (widget) {
                                vmBody.appendChild(createControlRow(name, typeLabel, typeClass, widget));
                                propCount++;
                            }
                        });
                    }
                } catch (e) { /* .properties not available on this VMI */ }
            });

            if (propCount === 0) {
                const empty = document.createElement('div');
                empty.className = 'empty-state';
                empty.innerHTML = '<div class="icon">🔍</div><p>No properties discovered automatically.<br>Check the console for diagnostics.</p>';
                vmBody.appendChild(empty);
            } else {
                log(`Total ControlsVM properties found: ${propCount}`, 'success');
            }

            controlsContainer.appendChild(vmSection);
            log('All controls built.', 'success');
        }

        // ─── Resize ─────────────────────────────────
        window.addEventListener('resize', () => {
            if (riveRecs) riveRecs.resizeDrawingSurfaceToCanvas();
            if (riveChart) riveChart.resizeDrawingSurfaceToCanvas();
        });

        // ─── Boot ───────────────────────────────────
        window.addEventListener('DOMContentLoaded', () => {
            if (typeof rive === 'undefined') {
                log('❌ Rive library failed to load!', 'error');
                return;
            }
            initRive();
        });
    </script>
</body>

</html>